package main

import "fmt"

func generate() chan int {
	ch := make(chan int)

	go func() {
		for i := 2; i < 100; i++ {
			ch <- i
		}
	}()
	return ch
}

func filter(in chan int, prime int) chan int {
	out := make(chan int)

	go func() {
		for {
			if i := <-in; i%prime != 0 {
				out <- i
			}
		}
	}()

	return out
}

func sieve() chan int {
	res := make(chan int)

	go func() {
		ch := generate()
		for {
			prime := <-ch
			ch = filter(ch, prime)
			res <- prime
		}
	}()
	return res
}

func main() {
	primes := sieve()
	for {
		fmt.Println(<-primes)
	}
}

// For the first prime number (which is 2), it is sent to the out channel before the filter function is applied.

// For subsequent prime numbers, the process is slightly different. Here's what happens:

// The sieve function receives a number from the ch channel. This number has already passed through all the filters created so far, so it is a prime number.

// The sieve function sends this prime number to its out channel.

// The sieve function then creates a new filter using this prime number. This filter will remove multiples of this prime number from the numbers generated by generate.

// So, for each prime number after the first, it is sent to the out channel before the new filter is created. But this prime number has already passed through all the previous filters, so it is indeed a prime number.
